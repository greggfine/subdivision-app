{"ast":null,"code":"/*\n\t----------------------------------------------------------------------\n\tadaptors-AudioAPI\n\t----------------------------------------------------------------------\n\thttp://webaudio.github.io/web-audio-api/\n\t----------------------------------------------------------------------\n*/\nwindow.AudioContext && function () {\n  'use strict';\n\n  var adaptors = MIDI.adaptors;\n  var midi = adaptors.audioapi = {};\n\n  var _ctx = createAudioContext();\n\n  var _buffers = {}; // downloaded & decoded audio buffers\n\n  var _requests = adaptors._requests; // queue\n\n  var _apply = {};\n  var _scheduled = {}; // audio sources that are scheduled to play\n\n  /** connect **/\n\n  midi.connect = function (args) {\n    MIDI.adaptor.id = 'audioapi';\n    /** properties **/\n\n    defineProperties();\n    /** volume **/\n\n    _apply.volume = function (source) {\n      var node = source.gainNode.gain;\n      var channel = source._channel;\n      /* set value */\n\n      if (MIDI.mute || channel.mute) {\n        node.value = 0.0;\n      } else {\n        var volume = MIDI.volume * channel.volume * source._volume;\n        node.value = Math.min(2.0, Math.max(0.0, volume));\n      }\n      /* reschedule fadeout */\n\n\n      if (node._fadeout) {\n        node.cancelScheduledValues(_ctx.currentTime);\n        node.linearRampToValueAtTime(node.value, node._startAt);\n        node.linearRampToValueAtTime(0.0, node._startAt + 0.3);\n      }\n    };\n    /** detune **/\n\n\n    _apply.detune = function (source) {\n      if (_ctx.hasDetune) {\n        var channel = source._channel;\n        var detune = MIDI.detune + channel.detune;\n\n        if (detune) {\n          source.detune.value = detune; // -1200 to 1200 - value in cents [100 cents per semitone]\n        }\n      }\n    };\n    /** fx **/\n\n\n    _apply.fx = function (source) {\n      var channel = source._channel;\n      var chain = source.gainNode;\n      source.disconnect(0);\n      source.connect(chain);\n      apply(MIDI.fxNodes); // apply master effects\n\n      apply(channel.fxNodes); // apply channel effects //- trigger refresh when this changes\n\n      function apply(nodes) {\n        if (nodes) {\n          for (var type in nodes) {\n            var node = nodes[type];\n            chain.connect(node.input);\n            chain = node;\n          }\n        }\n      }\n\n      ;\n    };\n    /** noteOn/Off **/\n\n\n    MIDI.noteOn = function (channelId, noteId, velocity, delay) {\n      switch (typeof noteId) {\n        case 'number':\n          return noteOn.apply(null, arguments);\n\n        case 'string':\n          break;\n\n        case 'object':\n          return noteGroupOn.apply(null, arguments);\n      }\n    };\n\n    MIDI.noteOff = function (channelId, noteId, delay) {\n      switch (typeof noteId) {\n        case 'number':\n          return noteOff.apply(null, arguments);\n\n        case 'string':\n          break;\n\n        case 'object':\n          return noteGroupOff.apply(null, arguments);\n      }\n    };\n    /** cancelNotes **/\n\n\n    MIDI.cancelNotes = function (channelId) {\n      if (isFinite(channelId)) {\n        stopChannel(channelId);\n      } else {\n        for (var channelId in _scheduled) {\n          stopChannel(channelId);\n        }\n      }\n\n      function stopChannel(channelId) {\n        loopChannel(channelId, function (sources, source) {\n          fadeOut(sources, source);\n        });\n      }\n    };\n    /** unlock **/\n\n\n    MIDI.iOSUnlock = function () {\n      if (_ctx.unlocked !== true) {\n        _ctx.unlocked = true;\n\n        var buffer = _ctx.createBuffer(1, 1, 44100);\n\n        var source = _ctx.createBufferSource();\n\n        source.buffer = buffer;\n        source.connect(_ctx.destination);\n        source.start(0);\n      }\n    }; // To take care of browsers who catch this as an \"auto play\" case.\n\n\n    if (_ctx.state === \"suspended\") _ctx.resume(); // TODO-PER: should actually wrap the following in a promise, but this is the simplest code change and the following promise will take a long time.\n\n    /** connect **/\n\n    return new Promise(function (resolve, reject) {\n      if (window.Tuna) {\n        if (!(_ctx.tunajs instanceof Tuna)) {\n          _ctx.tunajs = new Tuna(_ctx);\n        }\n      }\n\n      var soundfonts = MIDI.Soundfont;\n      var requests = Object.keys(soundfonts);\n\n      for (var programId in soundfonts) {\n        var program = MIDI.getProgram(programId);\n\n        if (program) {\n          var request = _requests[programId] || (_requests[programId] = {});\n\n          if (request.loaded) {\n            continue;\n          } else if (request.decoding) {\n            request.queue.push(resolve);\n          } else {\n            request.decoding = true;\n            request.queue.push(resolve);\n            request.pending = 0;\n            var soundfont = soundfonts[programId];\n\n            for (var noteName in soundfont) {\n              loadAudio(programId, program.id, noteName);\n            }\n          }\n        }\n      }\n\n      setTimeout(waitForEnd, 0);\n      /* helpers */\n\n      function waitForEnd() {\n        for (var i = 0; i < requests.length; i++) {\n          var program = requests[i];\n          var request = _requests[program];\n\n          if (request.pending) {\n            return;\n          }\n        }\n\n        for (var i = 0; i < requests.length; i++) {\n          var program = requests[i];\n          var request = _requests[program];\n          var cb;\n\n          while (cb = request.queue.pop()) {\n            cb();\n          }\n        }\n      }\n\n      function loadAudio(program, programId, noteName) {\n        var request = _requests[program];\n        var soundfont = soundfonts[program];\n        var path = soundfont[noteName];\n\n        if (path) {\n          request.pending++;\n          loadBuffer(path).then(function (buffer) {\n            buffer.id = noteName;\n            var noteId = MIDI.getNoteNumber(noteName);\n            var bufferId = programId + 'x' + noteId;\n            _buffers[bufferId] = buffer;\n\n            if (! --request.pending) {\n              request.decoding = false;\n              request.loading = false;\n              request.loaded = true;\n              MIDI.DEBUG && console.log('loaded: ', program);\n              waitForEnd();\n            }\n          }).catch(function (err) {\n            MIDI.DEBUG && console.error('audio could not load', arguments);\n          });\n        }\n      }\n    });\n\n    function noteOn(channelId, noteId, velocity, delay) {\n      delay = delay || 0;\n      var source;\n      var sourceId;\n      var volume = MIDI.volume;\n\n      if (volume) {\n        var channel = MIDI.channels[channelId];\n        var programId = channel.program;\n        var bufferId = programId + 'x' + noteId;\n        var buffer = _buffers[bufferId];\n\n        if (buffer) {\n          source = _ctx.createBufferSource();\n          source.buffer = buffer;\n          source.gainNode = _ctx.createGain();\n          source.gainNode.connect(_ctx.destination);\n          source._channel = channel;\n          source._volume = velocity;\n\n          _apply.volume(source);\n\n          _apply.detune(source);\n\n          _apply.fx(source);\n\n          source.start(delay + _ctx.currentTime);\n          _scheduled[channelId] = _scheduled[channelId] || {};\n          _scheduled[channelId][noteId] = _scheduled[channelId][noteId] || [];\n\n          _scheduled[channelId][noteId].push(source);\n\n          _scheduled[channelId][noteId].active = source;\n        } else {\n          MIDI.DEBUG && console.error(['no buffer', arguments]);\n        }\n      }\n\n      return {\n        cancel: function () {\n          source && source.disconnect(0);\n        }\n      };\n    }\n    /** noteOn/Off **/\n\n\n    function noteOff(channelId, noteId, delay) {\n      delay = delay || 0;\n      var channels = _scheduled[channelId];\n\n      if (channels) {\n        var sources = channels[noteId];\n\n        if (sources) {\n          var source = sources.active;\n\n          if (source) {\n            fadeOut(sources, source, delay);\n          }\n        }\n      }\n\n      return {\n        cancel: function () {\n          source && source.disconnect(0);\n        }\n      };\n    }\n\n    function noteGroupOn(channel, chord, velocity, delay) {\n      var res = {};\n\n      for (var n = 0, note, len = chord.length; n < len; n++) {\n        res[note = chord[n]] = MIDI.noteOn(channel, note, velocity, delay);\n      }\n\n      return res;\n    }\n\n    function noteGroupOff(channel, chord, delay) {\n      var res = {};\n\n      for (var n = 0, note, len = chord.length; n < len; n++) {\n        res[note = chord[n]] = MIDI.noteOff(channel, note, delay);\n      }\n\n      return res;\n    }\n\n    function fadeOut(sources, source, delay) {\n      var startAt = (delay || 0) + _ctx.currentTime; // @Miranet: 'the values of 0.2 and 0.3 could of course be used as \n      // a 'release' parameter for ADSR like time settings.'\n      // add { 'metadata': { release: 0.3 } } to soundfont files\n\n      var gain = source.gainNode.gain;\n      gain._fadeout = true;\n      gain._startAt = startAt;\n      gain.linearRampToValueAtTime(gain.value, startAt);\n      gain.linearRampToValueAtTime(0.0, startAt + 0.3);\n      source.stop(startAt + 0.5);\n      setTimeout(function () {\n        sources.shift();\n      }, delay * 1000);\n    }\n\n    function loadBuffer(path) {\n      // streaming | base64 | arraybuffer\n      return new Promise(function (resolve, reject) {\n        if (path.indexOf('data:audio') === 0) {\n          // Base64 string\n          decode(base64ToBuffer(path));\n        } else {\n          // XMLHTTP buffer\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', path, true);\n          xhr.responseType = 'arraybuffer';\n\n          xhr.onload = function () {\n            decode(xhr.response);\n          };\n\n          xhr.send();\n        }\n\n        function decode(buffer) {\n          _ctx.decodeAudioData(buffer, resolve, reject);\n        }\n      });\n    }\n  };\n\n  function base64ToBuffer(uri) {\n    uri = uri.split(',');\n    var binary = atob(uri[1]);\n    var mime = uri[0].split(':')[1].split(';')[0];\n    var buffer = new ArrayBuffer(binary.length);\n    var uint = new Uint8Array(buffer);\n\n    for (var n = 0; n < binary.length; n++) {\n      uint[n] = binary.charCodeAt(n);\n    }\n\n    return buffer;\n  }\n\n  function createAudioContext() {\n    _ctx = new (window.AudioContext || window.webkitAudioContext)();\n    _ctx.hasDetune = detectDetune();\n    return _ctx;\n  }\n\n  function detectDetune() {\n    var buffer = _ctx.createBuffer(1, 1, 44100);\n\n    var source = _ctx.createBufferSource();\n\n    try {\n      source.detune.value = 1200;\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function loopChannel(channelId, cb) {\n    var channel = _scheduled[channelId];\n\n    for (var noteId in channel) {\n      var sources = channel[noteId];\n      var source;\n\n      for (var i = 0; i < sources.length; i++) {\n        cb(sources, sources[i]);\n      }\n    }\n  }\n\n  function defineProperties() {\n    Object.defineProperties(MIDI, {\n      'context': {\n        configurable: true,\n        get: function () {\n          return _ctx;\n        },\n        set: function (ctx) {\n          _ctx = ctx;\n        }\n      },\n\n      /* effects */\n      'detune': set('number', 0, handler('detune')),\n      'fx': set('object', null, handler('fx')),\n      'mute': set('boolean', false, handler('volume')),\n      'volume': set('number', 1.0, handler('volume'))\n    });\n\n    function set(_format, _value, _handler) {\n      return {\n        configurable: true,\n        get: function () {\n          return _value;\n        },\n        set: function (value) {\n          if (typeof value === _format) {\n            _value = value;\n            _handler && _handler();\n          }\n        }\n      };\n    }\n\n    function handler(type) {\n      return function () {\n        MIDI.setProperty(type);\n      };\n    }\n\n    MIDI.setProperty = function (type, channelId) {\n      if (_apply[type]) {\n        if (isFinite(channelId)) {\n          type === 'fx' && prepareFX(MIDI.channels[channelId]);\n          setFX(channelId);\n        } else {\n          type === 'fx' && prepareFX(MIDI);\n\n          for (var channelId in _scheduled) {\n            setFX(channelId);\n          }\n        }\n      }\n\n      function setFX() {\n        loopChannel(channelId, function (sources, source) {\n          _apply[type](source);\n        });\n      }\n\n      function prepareFX(channel) {\n        var fxNodes = channel.fxNodes || (channel.fxNodes = {});\n\n        for (var key in fxNodes) {\n          fxNodes[key].disconnect(_ctx.destination);\n          delete fxNodes[key];\n        }\n\n        if (_ctx.tunajs) {\n          var fx = channel.fx;\n\n          for (var i = 0; i < fx.length; i++) {\n            var data = fx[i];\n            var type = data.type;\n            var effect = new _ctx.tunajs[type](data);\n            effect.connect(_ctx.destination);\n            fxNodes[type] = effect;\n          }\n        } else {\n          MIDI.DEBUG && console.error('fx not installed.', arguments);\n        }\n      }\n    };\n  }\n}();","map":{"version":3,"sources":["/Users/HTMusic/Desktop/PROJECTS/subdivision-app/subdivision-app_v2/node_modules/midi/js/adaptors-AudioAPI.js"],"names":["window","AudioContext","adaptors","MIDI","midi","audioapi","_ctx","createAudioContext","_buffers","_requests","_apply","_scheduled","connect","args","adaptor","id","defineProperties","volume","source","node","gainNode","gain","channel","_channel","mute","value","_volume","Math","min","max","_fadeout","cancelScheduledValues","currentTime","linearRampToValueAtTime","_startAt","detune","hasDetune","fx","chain","disconnect","apply","fxNodes","nodes","type","input","noteOn","channelId","noteId","velocity","delay","arguments","noteGroupOn","noteOff","noteGroupOff","cancelNotes","isFinite","stopChannel","loopChannel","sources","fadeOut","iOSUnlock","unlocked","buffer","createBuffer","createBufferSource","destination","start","state","resume","Promise","resolve","reject","Tuna","tunajs","soundfonts","Soundfont","requests","Object","keys","programId","program","getProgram","request","loaded","decoding","queue","push","pending","soundfont","noteName","loadAudio","setTimeout","waitForEnd","i","length","cb","pop","path","loadBuffer","then","getNoteNumber","bufferId","loading","DEBUG","console","log","catch","err","error","sourceId","channels","createGain","active","cancel","chord","res","n","note","len","startAt","stop","shift","indexOf","decode","base64ToBuffer","xhr","XMLHttpRequest","open","responseType","onload","response","send","decodeAudioData","uri","split","binary","atob","mime","ArrayBuffer","uint","Uint8Array","charCodeAt","webkitAudioContext","detectDetune","e","configurable","get","set","ctx","handler","_format","_value","_handler","setProperty","prepareFX","setFX","key","data","effect"],"mappings":"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","sourcesContent":["/*\n\t----------------------------------------------------------------------\n\tadaptors-AudioAPI\n\t----------------------------------------------------------------------\n\thttp://webaudio.github.io/web-audio-api/\n\t----------------------------------------------------------------------\n*/\n\nwindow.AudioContext && (function () { 'use strict';\n\n\tvar adaptors = MIDI.adaptors;\n\tvar midi = adaptors.audioapi = {};\n\t\n\tvar _ctx = createAudioContext();\n\tvar _buffers = {}; // downloaded & decoded audio buffers\n\tvar _requests = adaptors._requests; // queue\n\tvar _apply = {};\n\n\tvar _scheduled = {}; // audio sources that are scheduled to play\n\n\t/** connect **/\n\tmidi.connect = function (args) {\n\n\t\tMIDI.adaptor.id = 'audioapi';\n\n\n\t\t/** properties **/\n\t\tdefineProperties();\n\n\n\t\t/** volume **/\n\t\t_apply.volume = function (source) {\n\t\t\tvar node = source.gainNode.gain;\n\t\t\tvar channel = source._channel;\n\t\t\t\n\t\t\t/* set value */\n\t\t\tif (MIDI.mute || channel.mute) {\n\t\t\t\tnode.value = 0.0;\n\t\t\t} else {\n\t\t\t\tvar volume = MIDI.volume * channel.volume * source._volume;\n\t\t\t\tnode.value = Math.min(2.0, Math.max(0.0, volume));\n\t\t\t}\n\t\t\t\n\t\t\t/* reschedule fadeout */\n\t\t\tif (node._fadeout) {\n\t\t\t\tnode.cancelScheduledValues(_ctx.currentTime);\n\t\t\t\tnode.linearRampToValueAtTime(node.value, node._startAt);\n\t\t\t\tnode.linearRampToValueAtTime(0.0, node._startAt + 0.3);\n\t\t\t}\n\t\t};\n\n\n\t\t/** detune **/\n\t\t_apply.detune = function (source) {\n\t\t\tif (_ctx.hasDetune) {\n\t\t\t\tvar channel = source._channel;\n\t\t\t\tvar detune = MIDI.detune + channel.detune;\n\t\t\t\tif (detune) {\n\t\t\t\t\tsource.detune.value = detune; // -1200 to 1200 - value in cents [100 cents per semitone]\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\n\t\t/** fx **/\n\t\t_apply.fx = function (source) {\n\t\t\tvar channel = source._channel;\n\t\t\tvar chain = source.gainNode;\n\t\t\t\n\t\t\tsource.disconnect(0);\n\t\t\tsource.connect(chain);\n\t\t\t\n\t\t\tapply(MIDI.fxNodes); // apply master effects\n\t\t\tapply(channel.fxNodes); // apply channel effects //- trigger refresh when this changes\n\n\t\t\tfunction apply(nodes) {\n\t\t\t\tif (nodes) {\n\t\t\t\t\tfor (var type in nodes) {\n\t\t\t\t\t\tvar node = nodes[type];\n\t\t\t\t\t\tchain.connect(node.input);\n\t\t\t\t\t\tchain = node;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\t\n\t\t/** noteOn/Off **/\n\t\tMIDI.noteOn = function (channelId, noteId, velocity, delay) {\n\t\t\tswitch(typeof noteId) {\n\t\t\t\tcase 'number':\n\t\t\t\t\treturn noteOn.apply(null, arguments);\n\t\t\t\tcase 'string':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'object':\n\t\t\t\t\treturn noteGroupOn.apply(null, arguments);\n\t\t\t}\n\t\t};\n\n\t\tMIDI.noteOff = function (channelId, noteId, delay) {\n\t\t\tswitch(typeof noteId) {\n\t\t\t\tcase 'number':\n\t\t\t\t\treturn noteOff.apply(null, arguments);\n\t\t\t\tcase 'string':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'object':\n\t\t\t\t\treturn noteGroupOff.apply(null, arguments);\n\t\t\t}\n\t\t};\n\n\n\t\t/** cancelNotes **/\n\t\tMIDI.cancelNotes = function (channelId) {\n\t\t\tif (isFinite(channelId)) {\n\t\t\t\tstopChannel(channelId);\n\t\t\t} else {\n\t\t\t\tfor (var channelId in _scheduled) {\n\t\t\t\t\tstopChannel(channelId);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfunction stopChannel(channelId) {\n\t\t\t\tloopChannel(channelId, function (sources, source) {\n\t\t\t\t\tfadeOut(sources, source);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\n\t\t/** unlock **/\n\t\tMIDI.iOSUnlock = function () {\n\t\t\tif (_ctx.unlocked !== true) {\n\t\t\t\t_ctx.unlocked = true;\n\t\t\t\tvar buffer = _ctx.createBuffer(1, 1, 44100);\n\t\t\t\tvar source = _ctx.createBufferSource();\n\t\t\t\tsource.buffer = buffer;\n\t\t\t\tsource.connect(_ctx.destination);\n\t\t\t\tsource.start(0);\n\t\t\t}\n\t\t};\n\n\t\t// To take care of browsers who catch this as an \"auto play\" case.\n\t\tif (_ctx.state === \"suspended\")\n\t\t\t_ctx.resume(); // TODO-PER: should actually wrap the following in a promise, but this is the simplest code change and the following promise will take a long time.\n\n\t\t/** connect **/\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tif (window.Tuna) {\n\t\t\t\tif (!(_ctx.tunajs instanceof Tuna)) {\n\t\t\t\t\t_ctx.tunajs = new Tuna(_ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar soundfonts = MIDI.Soundfont;\n\t\t\tvar requests = Object.keys(soundfonts);\n\t\t\tfor (var programId in soundfonts) {\n\t\t\t\tvar program = MIDI.getProgram(programId);\n\t\t\t\tif (program) {\n\t\t\t\t\tvar request = _requests[programId] || (_requests[programId] = {});\n\t\t\t\t\tif (request.loaded) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (request.decoding) {\n\t\t\t\t\t\trequest.queue.push(resolve);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trequest.decoding = true;\n\t\t\t\t\t\trequest.queue.push(resolve);\n\t\t\t\t\t\trequest.pending = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar soundfont = soundfonts[programId];\n\t\t\t\t\t\tfor (var noteName in soundfont) {\n\t\t\t\t\t\t\tloadAudio(programId, program.id, noteName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsetTimeout(waitForEnd, 0);\n\n\t\t\t/* helpers */\n\t\t\tfunction waitForEnd() {\n\t\t\t\tfor (var i = 0; i < requests.length; i ++) {\n\t\t\t\t\tvar program = requests[i];\n\t\t\t\t\tvar request = _requests[program];\n\t\t\t\t\tif (request.pending) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < requests.length; i ++) {\n\t\t\t\t\tvar program = requests[i];\n\t\t\t\t\tvar request = _requests[program];\n\t\t\t\t\tvar cb;\n\t\t\t\t\twhile(cb = request.queue.pop()) {\n\t\t\t\t\t\tcb();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction loadAudio(program, programId, noteName) {\n\t\t\t\tvar request = _requests[program];\n\t\t\t\tvar soundfont = soundfonts[program];\n\t\t\t\tvar path = soundfont[noteName];\n\t\t\t\tif (path) {\n\t\t\t\t\trequest.pending ++;\n\t\t\t\t\tloadBuffer(path).then(function (buffer) {\n\t\t\t\t\t\tbuffer.id = noteName;\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar noteId = MIDI.getNoteNumber(noteName);\n\t\t\t\t\t\tvar bufferId = programId + 'x' + noteId;\n\t\t\t\t\t\t_buffers[bufferId] = buffer;\n\n\t\t\t\t\t\tif (!--request.pending) {\n\t\t\t\t\t\t\trequest.decoding = false;\n\t\t\t\t\t\t\trequest.loading = false;\n\t\t\t\t\t\t\trequest.loaded = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tMIDI.DEBUG && console.log('loaded: ', program);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\twaitForEnd();\n\t\t\t\t\t\t}\n\t\t\t\t\t}).catch(function (err) {\n\t\t\t\t\t\tMIDI.DEBUG && console.error('audio could not load', arguments);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tfunction noteOn(channelId, noteId, velocity, delay) {\n\t\t\tdelay = delay || 0;\n\n\t\t\tvar source;\n\t\t\tvar sourceId;\n\t\t\t\n\t\t\tvar volume = MIDI.volume;\n\t\t\tif (volume) {\n\t\t\t\tvar channel = MIDI.channels[channelId];\n\t\t\t\tvar programId = channel.program;\n\t\t\t\tvar bufferId = programId + 'x' + noteId;\n\t\t\t\tvar buffer = _buffers[bufferId];\n\t\t\t\tif (buffer) {\n\t\t\t\t\tsource = _ctx.createBufferSource();\n\t\t\t\t\tsource.buffer = buffer;\n\t\t\t\t\t\n\t\t\t\t\tsource.gainNode = _ctx.createGain();\n\t\t\t\t\tsource.gainNode.connect(_ctx.destination);\n\t\t\t\t\t\n\t\t\t\t\tsource._channel = channel;\n\t\t\t\t\tsource._volume = velocity;\n\t\t\t\t\t\n\t\t\t\t\t_apply.volume(source);\n\t\t\t\t\t_apply.detune(source);\n\t\t\t\t\t_apply.fx(source);\n\t\t\t\t\t\n\t\t\t\t\tsource.start(delay + _ctx.currentTime);\n\t\t\t\t\t\n\t\t\t\t\t_scheduled[channelId] = _scheduled[channelId] || {};\n\t\t\t\t\t_scheduled[channelId][noteId] = _scheduled[channelId][noteId] || [];\n\t\t\t\t\t_scheduled[channelId][noteId].push(source);\n\t\t\t\t\t_scheduled[channelId][noteId].active = source;\n\t\t\t\t} else {\n\t\t\t\t\tMIDI.DEBUG && console.error(['no buffer', arguments]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tcancel: function () {\n\t\t\t\t\tsource && source.disconnect(0);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\t\n\n\t\t/** noteOn/Off **/\n\t\tfunction noteOff(channelId, noteId, delay) {\n\t\t\tdelay = delay || 0;\n\t\t\t\n\t\t\tvar channels = _scheduled[channelId];\n\t\t\tif (channels) {\n\t\t\t\tvar sources = channels[noteId];\n\t\t\t\tif (sources) {\n\t\t\t\t\tvar source = sources.active;\n\t\t\t\t\tif (source) {\n\t\t\t\t\t\tfadeOut(sources, source, delay);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tcancel: function () {\n\t\t\t\t\tsource && source.disconnect(0);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\tfunction noteGroupOn(channel, chord, velocity, delay) {\n\t\t\tvar res = {};\n\t\t\tfor (var n = 0, note, len = chord.length; n < len; n++) {\n\t\t\t\tres[note = chord[n]] = MIDI.noteOn(channel, note, velocity, delay);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tfunction noteGroupOff(channel, chord, delay) {\n\t\t\tvar res = {};\n\t\t\tfor (var n = 0, note, len = chord.length; n < len; n++) {\n\t\t\t\tres[note = chord[n]] = MIDI.noteOff(channel, note, delay);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tfunction fadeOut(sources, source, delay) {\n\t\t\tvar startAt = (delay || 0) + _ctx.currentTime;\n\n\t\t\t// @Miranet: 'the values of 0.2 and 0.3 could of course be used as \n\t\t\t// a 'release' parameter for ADSR like time settings.'\n\t\t\t// add { 'metadata': { release: 0.3 } } to soundfont files\n\t\t\tvar gain = source.gainNode.gain;\n\t\t\tgain._fadeout = true;\n\t\t\tgain._startAt = startAt;\n\t\t\tgain.linearRampToValueAtTime(gain.value, startAt);\n\t\t\tgain.linearRampToValueAtTime(0.0, startAt + 0.3);\n\t\t\t\n\t\t\tsource.stop(startAt + 0.5);\n\t\t\t\n\t\t\tsetTimeout(function () {\n\t\t\t\tsources.shift();\n\t\t\t}, delay * 1000);\n\t\t}\n\n\t\tfunction loadBuffer(path) { // streaming | base64 | arraybuffer\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tif (path.indexOf('data:audio') === 0) { // Base64 string\n\t\t\t\t\tdecode(base64ToBuffer(path));\n\t\t\t\t} else { // XMLHTTP buffer\n\t\t\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\t\t\txhr.open('GET', path, true);\n\t\t\t\t\txhr.responseType = 'arraybuffer';\n\t\t\t\t\txhr.onload = function () {\n\t\t\t\t\t\tdecode(xhr.response);\n\t\t\t\t\t};\n\t\t\t\t\txhr.send();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfunction decode(buffer) {\n\t\t\t\t\t_ctx.decodeAudioData(buffer, resolve, reject);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\t\n\tfunction base64ToBuffer(uri) {\n\t\turi = uri.split(',');\n\t\tvar binary = atob(uri[1]);\n\t\tvar mime = uri[0].split(':')[1].split(';')[0];\n\t\tvar buffer = new ArrayBuffer(binary.length);\n\t\tvar uint = new Uint8Array(buffer);\n\t\tfor (var n = 0; n < binary.length; n++) {\n\t\t\tuint[n] = binary.charCodeAt(n);\n\t\t}\n\t\treturn buffer;\n\t}\n\n\tfunction createAudioContext() {\n\t\t_ctx = new (window.AudioContext || window.webkitAudioContext)();\n\t\t_ctx.hasDetune = detectDetune();\n\t\treturn _ctx;\n\t}\n\n\tfunction detectDetune() {\n\t\tvar buffer = _ctx.createBuffer(1, 1, 44100);\n\t\tvar source = _ctx.createBufferSource();\n\t\ttry {\n\t\t\tsource.detune.value = 1200;\n\t\t\treturn true;\n\t\t} catch(e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction loopChannel(channelId, cb) {\n\t\tvar channel = _scheduled[channelId];\n\t\tfor (var noteId in channel) {\n\t\t\tvar sources = channel[noteId];\n\t\t\tvar source;\n\t\t\tfor (var i = 0; i < sources.length; i ++) {\n\t\t\t\tcb(sources, sources[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction defineProperties() {\n\t\tObject.defineProperties(MIDI, {\n\t\t\t'context': {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn _ctx;\n\t\t\t\t},\n\t\t\t\tset: function (ctx) {\n\t\t\t\t\t_ctx = ctx;\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t/* effects */\n\t\t\t'detune': set('number', 0, handler('detune')),\n\t\t\t'fx': set('object', null, handler('fx')),\n\t\t\t'mute': set('boolean', false, handler('volume')),\n\t\t\t'volume': set('number', 1.0, handler('volume'))\n\t\t});\n\t\n\t\tfunction set(_format, _value, _handler) {\n\t\t\treturn {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn _value;\n\t\t\t\t},\n\t\t\t\tset: function (value) {\n\t\t\t\t\tif (typeof value === _format) {\n\t\t\t\t\t\t_value = value;\n\t\t\t\t\t\t_handler && _handler();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction handler(type) {\n\t\t\treturn function () {\n\t\t\t\tMIDI.setProperty(type);\n\t\t\t};\n\t\t}\n\t\t\n\t\tMIDI.setProperty = function (type, channelId) {\n\t\t\tif (_apply[type]) {\n\t\t\t\tif (isFinite(channelId)) {\n\t\t\t\t\ttype === 'fx' && prepareFX(MIDI.channels[channelId]);\n\t\t\t\t\tsetFX(channelId);\n\t\t\t\t} else {\n\t\t\t\t\ttype === 'fx' && prepareFX(MIDI);\n\t\t\t\t\tfor (var channelId in _scheduled) {\n\t\t\t\t\t\tsetFX(channelId);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfunction setFX() {\n\t\t\t\tloopChannel(channelId, function (sources, source) {\n\t\t\t\t\t_apply[type](source);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction prepareFX(channel) {\n\t\t\t\tvar fxNodes = channel.fxNodes || (channel.fxNodes = {});\n\t\t\t\tfor (var key in fxNodes) {\n\t\t\t\t\tfxNodes[key].disconnect(_ctx.destination);\n\t\t\t\t\tdelete fxNodes[key];\n\t\t\t\t}\n\t\t\t\tif (_ctx.tunajs) {\n\t\t\t\t\tvar fx = channel.fx;\n\t\t\t\t\tfor (var i = 0; i < fx.length; i ++) {\n\t\t\t\t\t\tvar data = fx[i];\n\t\t\t\t\t\tvar type = data.type;\n\t\t\t\t\t\tvar effect = new _ctx.tunajs[type](data);\n\t\t\t\t\t\teffect.connect(_ctx.destination);\n\t\t\t\t\t\tfxNodes[type] = effect;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tMIDI.DEBUG && console.error('fx not installed.', arguments);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n})();"]},"metadata":{},"sourceType":"script"}