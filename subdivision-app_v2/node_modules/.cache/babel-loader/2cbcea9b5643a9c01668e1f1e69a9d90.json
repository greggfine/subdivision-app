{"ast":null,"code":"import { shuffle } from \"lodash\";\nimport startStopTimes from \"../startStopData\"; // our array of objs in a shuffled order\n\nconst shuffledStartStopTimes = shuffle(startStopTimes);\nlet count = 0; // playNext state starts off as an object with\n//  startStopTimes being the first obj from shuff array\n// wrongNotation being the next obj from shuff array\n\nexport const playNextReducer = ( //   state = shuffledStartStopTimes[count],\nstate = {\n  startStopTimes: shuffledStartStopTimes[count],\n  wrongNotation: shuffledStartStopTimes[count + 1]\n}, action) => {\n  switch (action.type) {\n    case \"PLAY_NEXT\":\n      //   return shuffledStartStopTimes[count++];\n      return {\n        startStopTimes: shuffledStartStopTimes[count += 1],\n        // wrongNotation: shuffledStartStopTimes[count++]\n        wrongNotation: shuffledStartStopTimes[count += 2]\n      };\n\n    default:\n      return state;\n  }\n};\n/* \nInstead of returning an object from the array.\nLet's return an object containing an\n    object from the array as well\n    as the notation from a different object in the\n    array\n\n*/","map":{"version":3,"sources":["/Users/HTMusic/Desktop/PROJECTS/subdivision-app/subdivision-app_v2/src/reducers/playNextReducer.js"],"names":["shuffle","startStopTimes","shuffledStartStopTimes","count","playNextReducer","state","wrongNotation","action","type"],"mappings":"AAAA,SAASA,OAAT,QAAwB,QAAxB;AACA,OAAOC,cAAP,MAA2B,kBAA3B,C,CAEA;;AACA,MAAMC,sBAAsB,GAAGF,OAAO,CAACC,cAAD,CAAtC;AAEA,IAAIE,KAAK,GAAG,CAAZ,C,CAEA;AACA;AACA;;AACA,OAAO,MAAMC,eAAe,GAAG,EAC7B;AACAC,KAAK,GAAG;AACNJ,EAAAA,cAAc,EAAEC,sBAAsB,CAACC,KAAD,CADhC;AAENG,EAAAA,aAAa,EAAEJ,sBAAsB,CAACC,KAAK,GAAG,CAAT;AAF/B,CAFqB,EAM7BI,MAN6B,KAO1B;AACH,UAAQA,MAAM,CAACC,IAAf;AACE,SAAK,WAAL;AACE;AACA,aAAO;AACLP,QAAAA,cAAc,EAAEC,sBAAsB,CAAEC,KAAK,IAAI,CAAX,CADjC;AAEL;AACAG,QAAAA,aAAa,EAAEJ,sBAAsB,CAAEC,KAAK,IAAI,CAAX;AAHhC,OAAP;;AAKF;AACE,aAAOE,KAAP;AATJ;AAWD,CAnBM;AAqBP","sourcesContent":["import { shuffle } from \"lodash\";\nimport startStopTimes from \"../startStopData\";\n\n// our array of objs in a shuffled order\nconst shuffledStartStopTimes = shuffle(startStopTimes);\n\nlet count = 0;\n\n// playNext state starts off as an object with\n//  startStopTimes being the first obj from shuff array\n// wrongNotation being the next obj from shuff array\nexport const playNextReducer = (\n  //   state = shuffledStartStopTimes[count],\n  state = {\n    startStopTimes: shuffledStartStopTimes[count],\n    wrongNotation: shuffledStartStopTimes[count + 1]\n  },\n  action\n) => {\n  switch (action.type) {\n    case \"PLAY_NEXT\":\n      //   return shuffledStartStopTimes[count++];\n      return {\n        startStopTimes: shuffledStartStopTimes[(count += 1)],\n        // wrongNotation: shuffledStartStopTimes[count++]\n        wrongNotation: shuffledStartStopTimes[(count += 2)]\n      };\n    default:\n      return state;\n  }\n};\n\n/* \nInstead of returning an object from the array.\nLet's return an object containing an\n    object from the array as well\n    as the notation from a different object in the\n    array\n\n*/\n"]},"metadata":{},"sourceType":"module"}